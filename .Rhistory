names(vimp_drf)<- colnames(X)
resDRF_native[[b]]<-evalfinal(vimp_drf, X ,Y ,Xtest, Ytest, metrics=c("NPLD"), num.trees=500 )
# Sobol MDA
sobolMDAj <- list()
for (j in 1:ncol(Y)){
XY <- as.data.frame(cbind(X, Y[, j]))
colnames(XY) <- c(paste('X', 1:(ncol(XY)-1), sep=''), 'Y')
num.trees <- 500
clock <- Sys.time()
forest <- sobolMDA::ranger(Y ~., data = XY, num.trees = num.trees, importance = 'sobolMDA')
duration <- Sys.time() - clock
print(duration)
forest$r.squared
sobolMDAj[[j]] <- forest$variable.importance
}
sobolMDA<-colMeans(do.call(rbind,sobolMDAj))
names(sobolMDA)<- colnames(X)
ressobolMDA[[b]]<-evalfinal(sobolMDA, X ,Y ,Xtest, Ytest, metrics=c("MMD"), num.trees=500 )
}
save(resDRF, resDRF_native, ressobolMDA, X, Y, Xtest, Ytest, n, ntest, file=paste0("real_airdata_n=", n))
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("NPLD"), num.trees=500 )
source("~/GitHub/DRFvarimporance/evaluation.r")
resDRF
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("NPLD"), num.trees=500 )
set.seed(10)
n<-4000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-1
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_airdata", n = n)
#tmp<-genData(dataset = "motivatingexample", n = n)
X<-tmp$X
Y<-as.matrix(tmp$y)
if (is.null(colnames(X))){
colnames(X) <- paste0("X",1:ncol(X))
}
Xtest <- X[(round(n - ntest) + 1):n, , drop = F]
Ytest <- Y[(round(n - ntest) + 1):n, , drop = F]
#
X <- X[1:round(n - ntest), , drop = F]
Y <- Y[1:round(n - ntest), , drop = F]
for (b in 1:B){
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
(VIMPDRF<-sort(VIMPDRF))
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD"), num.trees=500 )
# vimp drf
DRF <- drf(X, Y, num.trees = 500)
vimp_drf <- variable_importance(DRF)
vimp_drf<-sort(c(vimp_drf))
names(vimp_drf)<- colnames(X)
resDRF_native[[b]]<-evalfinal(vimp_drf, X ,Y ,Xtest, Ytest, metrics=c("MMD"), num.trees=500 )
# Sobol MDA
sobolMDAj <- list()
for (j in 1:ncol(Y)){
XY <- as.data.frame(cbind(X, Y[, j]))
colnames(XY) <- c(paste('X', 1:(ncol(XY)-1), sep=''), 'Y')
num.trees <- 500
clock <- Sys.time()
forest <- sobolMDA::ranger(Y ~., data = XY, num.trees = num.trees, importance = 'sobolMDA')
duration <- Sys.time() - clock
print(duration)
forest$r.squared
sobolMDAj[[j]] <- forest$variable.importance
}
sobolMDA<-colMeans(do.call(rbind,sobolMDAj))
names(sobolMDA)<- colnames(X)
ressobolMDA[[b]]<-evalfinal(sobolMDA, X ,Y ,Xtest, Ytest, metrics=c("MMD"), num.trees=500 )
}
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD"), num.trees=500 )
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("NPLD"), num.trees=500 )
i
weights
nrow(Weights)
nrow(weights)
?rbfdot
w<-weights[1,]
Yx<-Y[sample(1:nrow(Y),size=1000, replace=T,prob=w),]
Yx
Hx=diag(apply( Yx, 2, drf:::medianHeuristic ))
Hx
Hxsqrtm1=diag( 1/sqrt(apply( Yx, 2, drf:::medianHeuristic )))
Hxsqrtm1
head(Yx)
Yx%*%Hxsqrtm1
Yx.transformed <- Yx%*%Hxsqrtm1
head(Yx.transformed)
diag(Hxsqrtm1)
diag(Hxsqrtm1)*Yx[1,]
y
Ytest
diag(Hxsqrtm1)*Ytest[1,]
Yx.transformed <- Yx%*%Hxsqrtm1
Ytest.transformed<-diag(Hxsqrtm1)*Ytest[1,]
K_x <- kernelMatrix(k_y, Yx.transformed, y = Ytest.transformed)
k_y <- rbfdot(sigma = 1)
K_x <- kernelMatrix(k_y, Yx.transformed, y = Ytest.transformed)
Ytest.transformed
Yx.transformed
K_x <- kernelMatrix(k_y, Yx.transformed, y = t(Ytest.transformed))
K_x
dim(K_x)
prod(diag(Hxsqrtm1))
1/n * prod(diag(Hxsqrtm1)) * sum(K_x)
res<-sapply(1:nrow(weights),  function(j){
cat(j)
Yx<-Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),]
Hxsqrtm1=diag( 1/sqrt(apply( Yx, 2, drf:::medianHeuristic )))
Yx.transformed <- Yx%*%Hxsqrtm1
Ytest.transformed<-diag(Hxsqrtm1)*Ytest[1,]
K_x <- kernelMatrix(k_y, Yx.transformed, y = t(Ytest.transformed))
1/n * prod(diag(Hxsqrtm1)) * sum(K_x)
}   )
res<-sapply(1:nrow(weights),  function(j){
cat(j)
Yx<-Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),]
Hxsqrtm1=diag( 1/sqrt(apply( Yx, 2, drf:::medianHeuristic )))
Yx.transformed <- Yx%*%Hxsqrtm1
Ytest.transformed<-diag(Hxsqrtm1)*Ytest[1,]
}   )
source("~/GitHub/DRFvarimporance/evaluation.r")
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD"), num.trees=500 )
set.seed(10)
n<-1000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-1
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_airdata", n = n)
X<-tmp$X
Y<-as.matrix(tmp$y)
if (is.null(colnames(X))){
colnames(X) <- paste0("X",1:ncol(X))
}
Xtest <- X[(round(n - ntest) + 1):n, , drop = F]
Ytest <- Y[(round(n - ntest) + 1):n, , drop = F]
#
X <- X[1:round(n - ntest), , drop = F]
Y <- Y[1:round(n - ntest), , drop = F]
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
(VIMPDRF<-sort(VIMPDRF))
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD"), num.trees=500 )
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("NPLD"), num.trees=500 )
source("~/GitHub/DRFvarimporance/evaluation.r")
debugSource("~/GitHub/DRFvarimporance/evaluation.r")
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("NPLD"), num.trees=500 )
Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),]
Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[1:2,]),]
lapply(1:nrow(w), function(j) Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),] )
datax<-lapply(1:nrow(weights), function(j) Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),] )
datax[[1]]
Hx<-sapply(1:nrow(weights), function(j) 1/sqrt(apply( Yx[j,], 2, drf:::medianHeuristic )) )
j<-1
datax[[j]]
Hx<-sapply(1:nrow(weights), function(j) 1/sqrt(apply( datax[[j]], 2, drf:::medianHeuristic )) )
library(kernlab)
library(drf)
library(Matrix)
# Load necessary libraries
library(mvtnorm) # for generating multivariate normal random variables
library(ks)
library(doParallel)
library(dplyr)
library(kableExtra)
library(copula)
library("MulvariateRandomForestVarImp")
library(doParallel)
library(kernlab)
library(latex2exp)
source("drfnew_v2.R")
#source("applications")
source("genData.R")
source("evaluation.R")
source("compute_drf_vimp.R")
#cl <- makeCluster(detectCores()-1)
#registerDoParallel(cl)
set.seed(10)
n<-2000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-10
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_wagedata", n = n)
X<-tmp$X
Y<-as.matrix(tmp$y)
Xtest <- X[(round(n - ntest) + 1):n, , drop = F]
Ytest <- Y[(round(n - ntest) + 1):n, , drop = F]
#
X <- X[1:round(n - ntest), , drop = F]
Y <- Y[1:round(n - ntest), , drop = F]
b<-1
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
load("~/GitHub/DRFvarimporance/real_wagedata_n=2000")
resDRF[[1]]$Vimp
vimp_drf[[1]]
cbind(resDRF[[1]]$Vimp,resDRF_native[[1]]$Vimp)
vimp_drf[[1]]
resDRF_native[[1]]$Vimp
resDRF_native[[2]]$Vimp
library(kernlab)
library(drf)
library(Matrix)
# Load necessary libraries
library(mvtnorm) # for generating multivariate normal random variables
library(ks)
library(doParallel)
library(dplyr)
library(kableExtra)
library(copula)
library("MulvariateRandomForestVarImp")
library(doParallel)
library(kernlab)
library(latex2exp)
source("drfnew_v2.R")
#source("applications")
source("genData.R")
source("evaluation.R")
source("compute_drf_vimp.R")
#cl <- makeCluster(detectCores()-1)
#registerDoParallel(cl)
##########################################
### Start Evaluation of wage data #######
##########################################
start.time <- Sys.time()
set.seed(10)
n<-2000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-10
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_wagedata", n = n)
#tmp<-genData(dataset = "motivatingexample", n = n)
X<-tmp$X
Y<-as.matrix(tmp$y)
if (is.null(colnames(X))){
colnames(X) <- paste0("X",1:ncol(X))
}
Xtest <- X[(round(n - ntest) + 1):n, , drop = F]
Ytest <- Y[(round(n - ntest) + 1):n, , drop = F]
#
X <- X[1:round(n - ntest), , drop = F]
Y <- Y[1:round(n - ntest), , drop = F]
for (b in 1:B){
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
(VIMPDRF<-sort(VIMPDRF))
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
# vimp drf
DRF <- drf(X, Y, num.trees = 500)
vimp_drf <- variable_importance(DRF)
vimp_drf<-sort(c(vimp_drf))
names(vimp_drf)<- colnames(X)
resDRF_native[[b]]<-evalfinal(vimp_drf, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
# Sobol MDA
sobolMDAj <- list()
for (j in 1:ncol(Y)){
XY <- as.data.frame(cbind(X, Y[, j]))
colnames(XY) <- c(paste('X', 1:(ncol(XY)-1), sep=''), 'Y')
num.trees <- 500
clock <- Sys.time()
forest <- sobolMDA::ranger(Y ~., data = XY, num.trees = num.trees, importance = 'sobolMDA')
duration <- Sys.time() - clock
print(duration)
forest$r.squared
sobolMDAj[[j]] <- forest$variable.importance
}
sobolMDA<-colMeans(do.call(rbind,sobolMDAj))
names(sobolMDA)<- colnames(X)
ressobolMDA[[b]]<-evalfinal(sobolMDA, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
}
y
Ytrain
Y
resDRF
VIMPDRF
# vimp drf
DRF <- drf(X, Y, num.trees = 500)
vimp_drf <- variable_importance(DRF)
vimp_drf<-sort(c(vimp_drf))
names(vimp_drf)<- colnames(X)
vimp_drf
start.time <- Sys.time()
set.seed(10)
n<-2000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-5
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_wagedata", n = n)
library(kernlab)
library(drf)
library(Matrix)
# Load necessary libraries
library(mvtnorm) # for generating multivariate normal random variables
library(ks)
library(doParallel)
library(dplyr)
library(kableExtra)
library(copula)
library("MulvariateRandomForestVarImp")
library(doParallel)
library(kernlab)
library(latex2exp)
source("drfnew_v2.R")
#source("applications")
source("genData.R")
source("evaluation.R")
source("compute_drf_vimp.R")
b<-1
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
(VIMPDRF<-sort(VIMPDRF))
set.seed(10)
n<-2000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-5
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_wagedata", n = n)
#tmp<-genData(dataset = "motivatingexample", n = n)
X<-tmp$X
Y<-as.matrix(tmp$y)
if (is.null(colnames(X))){
colnames(X) <- paste0("X",1:ncol(X))
}
Xtest <- X[(round(n - ntest) + 1):n, , drop = F]
Ytest <- Y[(round(n - ntest) + 1):n, , drop = F]
#
X <- X[1:round(n - ntest), , drop = F]
Y <- Y[1:round(n - ntest), , drop = F]
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
load("~/GitHub/DRFvarimporance/real_wagedata_n=2000")
evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
VIMPDRF<-resDRF[[1]]$Vimp
evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
Y
i<.1
i<-1
Yx<-Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),]
j<-1
Yx<-Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),]
Hxsqrtm1=diag( 1/sqrt(apply( Yx, 2, drf:::medianHeuristic )))
Yx<-Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),,drop=F]
head(Yx)
debugSource("~/GitHub/DRFvarimporance/evaluation.r")
evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
j<-1
Yx<-Y[sample(1:nrow(Y),size=1000, replace=T,prob=weights[j,]),, drop=F]
Hxsqrtm1=diag( 1/sqrt(apply( Yx, 2, drf:::medianHeuristic )))
Yx.transformed <- Yx%*%Hxsqrtm1
Ytest.transformed<-diag(Hxsqrtm1)*Ytest[1,]
K_x <- kernelMatrix(k_y, Yx.transformed, y = t(Ytest.transformed))
-1/n * prod(diag(Hxsqrtm1)) * sum(K_x)
debugSource("~/GitHub/DRFvarimporance/evaluation.r")
set.seed(10)
n<-2000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-5
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_wagedata", n = n)
#tmp<-genData(dataset = "motivatingexample", n = n)
X<-tmp$X
Y<-as.matrix(tmp$y)
if (is.null(colnames(X))){
colnames(X) <- paste0("X",1:ncol(X))
}
Xtest <- X[(round(n - ntest) + 1):n, , drop = F]
Ytest <- Y[(round(n - ntest) + 1):n, , drop = F]
#
X <- X[1:round(n - ntest), , drop = F]
Y <- Y[1:round(n - ntest), , drop = F]
for (b in 1:B){
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
(VIMPDRF<-sort(VIMPDRF))
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
# vimp drf
DRF <- drf(X, Y, num.trees = num.trees)
vimp_drf <- variable_importance(DRF)
vimp_drf<-sort(c(vimp_drf))
names(vimp_drf)<- colnames(X)
resDRF_native[[b]]<-evalfinal(vimp_drf, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
# Sobol MDA
sobolMDAj <- list()
for (j in 1:ncol(Y)){
XY <- as.data.frame(cbind(X, Y[, j]))
colnames(XY) <- c(paste('X', 1:(ncol(XY)-1), sep=''), 'Y')
num.trees <- 500
clock <- Sys.time()
forest <- sobolMDA::ranger(Y ~., data = XY, num.trees = num.trees, importance = 'sobolMDA')
duration <- Sys.time() - clock
print(duration)
forest$r.squared
sobolMDAj[[j]] <- forest$variable.importance
}
sobolMDA<-colMeans(do.call(rbind,sobolMDAj))
names(sobolMDA)<- colnames(X)
ressobolMDA[[b]]<-evalfinal(sobolMDA, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
}
source("~/GitHub/DRFvarimporance/evaluation.r")
for (b in 1:B){
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
(VIMPDRF<-sort(VIMPDRF))
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
# vimp drf
DRF <- drf(X, Y, num.trees = num.trees)
vimp_drf <- variable_importance(DRF)
vimp_drf<-sort(c(vimp_drf))
names(vimp_drf)<- colnames(X)
resDRF_native[[b]]<-evalfinal(vimp_drf, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
# Sobol MDA
sobolMDAj <- list()
for (j in 1:ncol(Y)){
XY <- as.data.frame(cbind(X, Y[, j]))
colnames(XY) <- c(paste('X', 1:(ncol(XY)-1), sep=''), 'Y')
num.trees <- 500
clock <- Sys.time()
forest <- sobolMDA::ranger(Y ~., data = XY, num.trees = num.trees, importance = 'sobolMDA')
duration <- Sys.time() - clock
print(duration)
forest$r.squared
sobolMDAj[[j]] <- forest$variable.importance
}
sobolMDA<-colMeans(do.call(rbind,sobolMDAj))
names(sobolMDA)<- colnames(X)
ressobolMDA[[b]]<-evalfinal(sobolMDA, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
}
B
b
ressobolMDA
resDRF_native
VIMPDRF
library(kernlab)
library(drf)
library(Matrix)
# Load necessary libraries
library(mvtnorm) # for generating multivariate normal random variables
library(ks)
library(doParallel)
library(dplyr)
library(kableExtra)
library(copula)
library("MulvariateRandomForestVarImp")
library(doParallel)
library(kernlab)
library(latex2exp)
source("drfnew_v2.R")
#source("applications")
source("genData.R")
source("evaluation.R")
source("compute_drf_vimp.R")
#cl <- makeCluster(detectCores()-1)
#registerDoParallel(cl)
start.time <- Sys.time()
set.seed(10)
n<-2000
ntest <- round(1/2*n)
num.trees<-500
set.seed(10)
B<-10
resDRF<-list()
resDRF_native<-list()
ressobolMDA<-list()
tmp<-genData(dataset = "real_wagedata", n = n)
X<-tmp$X
Y<-as.matrix(tmp$y)
if (is.null(colnames(X))){
colnames(X) <- paste0("X",1:ncol(X))
}
Xtest <- X[(round(n - ntest) + 1):n, , drop = F]
Ytest <- Y[(round(n - ntest) + 1):n, , drop = F]
#
X <- X[1:round(n - ntest), , drop = F]
Y <- Y[1:round(n - ntest), , drop = F]
X<-X[,1:10]
Xtest<-Xtext[,1:10]
Xtest<-Xtest[,1:10]
b
B
VIMPDRF<-compute_drf_vimp(X, Y, X_test = NULL, num.trees = 500, silent = FALSE)
(VIMPDRF<-sort(VIMPDRF))
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
source("~/GitHub/DRFvarimporance/evaluation.r")
resDRF[[b]]<-evalfinal(VIMPDRF, X ,Y ,Xtest, Ytest, metrics=c("MMD","NPLD","MAD"), num.trees=500 )
# vimp drf
DRF <- drf(X, Y, num.trees = 500)
vimp_drf <- variable_importance(DRF)
names(vimp_drf)<- colnames(X)
vimp_drf<-sort(c(vimp_drf))
vimp_drf
resDRF
VIMPDRF
